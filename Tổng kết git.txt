# Basic
git --version # show version của git
git --help 

Ghi tên folder/ => chú ý thư mục nên specific / đằng sau or nó có thể là file or symbolic link.
Dấu ! để phủ định. VD: !folder/file.exe
Dùng * để tìm các file cùng định dạng. VD: *.xml -> bỏ qua tất cả các file đuôi .xml
VD nếu chỉ rõ đường dẫn chỉ có hiệu lực cùng cấp. VD: config/*.xml => bỏ qua file config/abc.xml nhưng k có hiệu lực với config/sub/abc.xml
Sử dụng ** khi thư mục k định rõ tên. Vd: **/foo sẽ bỏ qua mọi file or thư mục có tên foo mọi nơi trong project.

-> Sửa config sẽ được lưu lại trong file cấu hình của thư mục git:
git config --list # Show mọi config
git config --global user.name "Tên của Bạn" # Thiết lập tên trên hệ thống git
git config --global user.email emailcuaban@domain.com # Thiết lập email
=> Dùng --global nếu muốn config có hiệu lực với user hiện tại của hệ thống; --system nếu muốn có hiệu lực với mọi user; k có 2 cái đó thì chỉ là chỉnh ở chính cấu hình thư mục .git của dự án, chỉ có tác dụng cho repos hiện tại

Đôi khi có các config ta set làm cho lệnh git bị lỗi => git config --global --edit xong vào trong xóa các config gây lỗi bằng phím delete thủ công và save lại.

-> git stash giúp save data ở local để chuyển sang nhánh khác nhưng k muốn commit: làm việc nhánh A -> sửa nhánh A -> save change -> git stash -> chuyển nhánh B -> thao tác nhánh B -> quay về checkout nhánh A -> git stash pop để lấy lại dữ liệu từng stash ở nhánh A

-> HEAD chỉ định 1 commit của 1 nhánh hiện tại mà ta đang làm việc. Nó được lưu trong file .git/HEAD => đôi khi nó k chứa tham chiếu branch cụ thể mà là giá trị SHA-1 của 1 version cụ thể, đó là khi detached HEAD xảy ra  
VD: git checkout -b test-branch 56a4e5c08 => ta quay lại commit 56a4e5c08 ở 1 nhánh mới là test-branch. Nếu k tạo như v thì commit 56a4e5c08 sẽ ở trạng thái detached HEAD



# init add commit status clone
-> git init: nếu k muốn push code lên mà chỉ muốn mình ta quản lý phiên bản thì tạo mỗi cái local repos này thôi cũng ok.
git init --bare => tạo 1 repo git chỉ có chức năng lưu trữ, k có thư mục làm việc. Nó thg dùng để lưu trữ như 1 remote repo như server, từ đó local clone về => sau khi dùng git init --bare thì như 1 remote repos r, ta có thể tạo 1 local repos remote or clone đến nó đều đc

-> git add <file/folder> sẽ đưa file, thư mục vào staging. Nó snapshot toàn bộ file/thư mục mới. Vc lưu lại snapshot của thư mục đang làm việc gọi là đánh chỉ mục index.
git add *.c => tất cả file đuôi c được giám sát
git add -u => tự động staged các file đã giám sát từ trước thì add tiếp, bỏ qua các file chưa đc từng được add, vd file mới tạo 

-> git status hiển thị sự khác biệt giữa vùng staged và commited.
git status -s/--short  thì: ' ' unmodified; M modified; A/? added; D deleted; R renamed; C copied; U updated but unmerged; 

-> git commit lưu thông tin vùng staging vào db, và con trỏ HEAD tự động dịch chuyển đến commit mới nhất. 
git commit -a -m "Ghi chú về commit" => -a chính là git add . kẹp vào => k nên dùng
git commit --amend -m "Message mới" 

Nếu muốn mở project ở lần commit đó để xem: git checkout <mã hash của commit> => lúc này git cmd đang thao tác sẽ ở trạng thái HEAD detached và đang ở 1 branch mới k thể thao tác.
Nếu ta muốn dùng 1 commit cũ của dự án hiện tại vào dự án hiện tại: git checkout <mã hash của commit> . => chú ý thêm dấu chấm, ta dùng commit và push lên thì sẽ khiến dự án hiện tại chỉnh sửa thành lúc nó ở commit cũ, điều đó thực hiện trên 1 commit mới

-> Resolve conflict: git add . => git commit -m "" => lỗi => git pull => resolve conflict => git add lại, commit, push
=> Khi làm nhiều người, luôn pull trước để xác nhận thay đổi, sau đó mới push vào

-> git clone <git path> <des> => des mặc định là thư mục hiện tại, git path có thể là https url, ssh, đường dẫn local drive => clone chỉ lấy nhánh chính đang hoạt động
git branch --remote => xem tất cả các nhánh của repos remote. Chú ý các branch của remote luôn có name dạng origin/<tên branch>
git clone -b <branch> <url> => chỉ clone về 1 nhánh
Nếu k dùng git clone mà git init rồi git remote add origin rồi pull từ dự án về cũng được. Lần pull đầu tiên: git branch --set-upstream-to=origin/<branch> master

HTTPS: đôi lúc phải nhập tk, mk (connect to git) để push sau khi clone
SSH: trao đổi thông qua 1 SSH key, khi dùng nó sẽ lưu SSH key vào bảng và tự gửi kèm mỗi lần thao tác để xác nhận




# git reset
git reset --soft HEAD~1 => hủy commit cuối, HEAD chuyển về commit trước đó, những thay đổi commit cuối chuyển về staging
git reset --hard HEAD~1 => tương tự --soft nhưng commit cuối k chuyển vào vùng staging mà bị hủy luôn, mất dữ liệu
git reset --hard => undo tất cả các lệnh git add chưa commit và mất hết data
git reset -- <tên file> => 1 file cụ thể được add vào vùng staging, giờ muốn xoá tất cả thay đổi đó
git reset --hard <hash> => xoá commit và code để quay về commit nào

git rm --cached <tên file> => xoá file nào và đưa việc xoá staged luôn, tương đương với việc xoá 1 file rồi git add



# git log
git log: w trang tiếp; space trang trước; :q thoát; ?pattern tìm; n vị trí tìm kiếm phía sau;
git log -2
git log -p -2
git log --stat/shortstat -5 => thống kê
git log --stat -10 --oneline => kết hợp
Lọc:
git log --after="<năm>-<tháng>-<ngày>" --before="2019-12-31"
git log --author="<tên author>"
git log --grep="<thông tin ghi chú về commit>" => lọc message của commit chứa j
git log --oneline -- <link đến file> => commit về 1 file cụ thể
git log --oneline --shortstat -S"chữ" => nội dung cập nhập có chữ gì
git log --merges/--no-merges => lọc các commit bth hay commit merges
format:
git log --pretty=format:"%h - %an %s - %H" --date="short" => format hiển thị theo ngày với %H là mã hash đủ, %h mã hash short, %an là người commit, %s là message commit
git log --graph --pretty="%h %an %s" --date="short" => trực quan nhất là xem đc merge như nào
git log --word-diff => xem rõ sự thay đổi từng từ 1 qua mỗi commit. Nội dung bị loại bỏ hiển thị trong [-<>-], nd thêm vào hiển thị trong {+<>+}
git log --pretty=oneline là dạng viết dài của git log --oneline sẽ in các commit theo thứ tự thời gian; git log -oneline graph sẽ in ra gộp nhánh

gitk xem giao diện luôn



# git diff
git diff => check thay đổi thư mục làm việc hiện tại với commit cuối
git diff --staged => check thay đổi index staging với commit cuối
git diff hash-commit1 hash-commit2
git diff branch1 branch2



# git checkout
git checkout <hash> <link file> => phục hồi nội dung file nào về 1 commit cũ, k có hash thì tự phục hồi về commit mới nhất
git checkout -- *.html => phục hồi tất cả file có đuôi html
git checkout -- . => phục hồi tất cả
git checkout <hash> => trở về 1 commit có mã hash nào đó. Head sẽ chuyển đến commit này ở chế độ detached, là 1 nhánh tạm thời được tạo ra. Nếu k lưu vào 1 nhánh khác thì nhánh tạm thời sẽ mất khi chuyển nhánh
=> git checkout thay thế git switch bỏ luôn
git restore . => tương đương git checkout -- .
git checkout -b <tên nhánh> => tạo nhánh mới copy thư mục làm việc hiện tại
git checkout -b <tên nhánh mới ở local> origin/<tên nhánh remote> => tạo nhánh mới ở local theo remote
git pull origin newBranch => pull 1 nhánh nào ở remote về nhánh hiện tại đang dùng ở local

git branch <tên branch> -> tạo 1 branch mới có mọi thứ của head hiện tại
git branch -m old_branch new_branch -> đổi tên của old branch thành tên mới ở local
git branch -v => liệt kê nhánh và commit cuối
git branch --merged/--no-merged => liệt kê các nhánh đc/k đc merge với nhánh hiện tại
git branch -a => hiển thị các nhánh có trên remote

Chú ý khi ta thao tác trên 1 nhánh và commit 2 lần -> sau đó merge với master và push lên -> cái master tự có thêm 2 commit kia, chứ nó k gom lại làm 1 commit merge. Nếu muốn giảm số lượng commit rác thành 1 commit thì phải dùng squash.



# git push
git push origin <tên nhánh remote> => push nhánh gì của local lên remote trùng tên nhé
git push --all => đẩy tất cả nhánh lên remote repos
git push --tags => đẩy tất cả tags lên server
git push --delete <tên nhánh> => xóa 1 nhánh trên server
git push -u origin master => -u chính là --set-upstream. Gắn luồng upload tương ứng với nhánh của local. Sau khi dùng như nhau, các lần sau chỉ cần gọi git push



# git remote
Lệnh git remote cho phép tạo, xóa kết nối giữa các local repos và remote repos: 
git remote
git remote -v -> hiển thị rõ hơn
git remote add <remote name> url
git remote rm <remote name>
git remote rename <old name> <new name>
git remote show <remote name>
git remote remove origin => xoá remote
git remote set-url origin git://new.url.here => set trực tiếp, k cần xoá vẫn set được
=> mỗi repos có 1 <remote name> riêng do ta tự đặt, mặc định là origin là tên remote repos đầu tiên
Nhánh ở local dùng trực tiếp tên nhánh. Nhánh ở remote chưa có ở local thì phải dùng origin/<tên nhánh ở remote>



# Hiểu git merge và git rebase
git merge <tên branch1> -m "comment" => merge cũng là 1 lệnh commit, thêm branch1 vào branch hiện tại
git merge so sánh commit cơ sở chung cuối cùng của 2 nhánh và 2 commit cuối của 2 nhánh. Nếu có xung đột phải tự xử lý và git add commit lại.

git rebase: base commit là các commit cơ sở của 1 nhánh. Khi đang ở nhánh A mà ta git rebase <nhánh B> thì mọi commit của nhánh B sẽ thành commit cơ sở của nhánh A. Các commit theo sau commit cơ sở của nhánh A sẽ thực hiện ngay sau đó, nếu các commit đó có conflict với các commit cơ sở mới thêm, ta phải chọn để xử lý conflict. git rebase --continue để chỉnh sửa các commit sau commit cơ sở của A thành 1 commit mới như những gì ta vừa chọn, có thể đổi message hay đổi tên sau đó nó sẽ tiếp tục như v đến khi hết các commit của A thì rebase xong

rebase là biến các commit nào thành base r sửa từng commit của nhánh này theo base. Dùng khi muốn chắc chắn tất cả commit của branch nào, sau đó các branch phụ ta add thêm các thứ vào branch chính đó.
merge là ta so sánh 2 commit cuối cùng của 2 nhánh và tiến hành chọn cái nào khác biệt thôi.

-> VD merge:
Alpha: C1 -> C2 -> C3   ->   C4
Beta:  C1 -> C2 ->   C5 -> C6
=> git checkout Alpha -> git merge Beta -> Nhánh Alpha biến thành: C1 -> C2 -> C3 -> C5 -> C6 -> C4 -> Merge Commit (resolve conflict)
VD rebase:
Alpha: C1 -> C2 -> C3   ->   C4
Beta:  C1 -> C2 ->   C5 -> C6
=> git checkout Alpha -> git rebase Beta -> Nhánh Alpha biến thành: C1 -> C2 -> C5 -> C6 -> C3' -> C4'
C3' và C4' là 2 commit C3 C4 của Alpha bị sửa đổi lại cho phù hợp với base commit C1->C2->C5->C6 

VD rebase dùng kiểu 1 branch fix lỗi, 1 branch đang làm việc. Sau khi kết thúc ta rebase branch đang làm việc thành base chính, sau đó branch fix lỗi ta chỉ add thêm cái gì vào branch chính thì ok
VD xử lý nhánh quá tuyệt vời, chơi cả xung đột nhánh khi gộp luôn: https://xuanthulab.net/lam-viec-voi-nhanh-branch-tao-nhanh-gop-nhanh-trong-git.html

=> Đa số TH dùng merge nhưng khi phức tạp cần phải đổi cả commit base thì nên dùng rebase.
Tình huống: 1 công ty làm 1 sản phẩm chia 2 nhánh. 1 nhánh do 1 team phát triển sản phẩm. 1 nhánh do 1 team chuyên fix bug. Khi bàn giao sản phẩm phải gộp lại. Khi đó ta dùng merge thì sẽ rất loạn nếu dự án lớn. Nhưng dùng base thì ta sẽ fix từng commit 1 theo trình tự thời gian thì ta sẽ so sánh được file nào được xử lý bug ntn và đổi commit tốt hơn:
git checkout develop -> git merge bugfix -> or ngược lại đều đc
git checkout bugfix -> git rebase develop -> đúng thứ tự này vì develop phải là base r sau đó mới fix bug đc chứ

-> Để tránh nhầm, luôn hình dung vị trí của head và sơ đồ của các nhánh trong đầu
VD: đang có commit C1 ở master -> git checkout test1 -> <tạo 2 commit C2->C3> -> git checkout master -> git merge test1 
Nhánh master: C1 -> C3
Nhánh test1: C1 -> C2 -> C3

-> git branch -d <tên nhánh muốn xóa> => xóa ở local
git push origin --delete <tên branch> => xóa ở remote

-> Dùng git rebase => việc thay đổi lịch sử commit làm cho lệnh này rất phức tạp và k đc dùng nó khi đã push lên remote repos k thì sẽ rối tung
Đang ở nhánh B, git rebase <tên nhánh A> sẽ cho những commit của nhánh A áp dụng lên nhánh B. Chỉnh sửa chọn cái nào muốn lấy r add r git rebase --continue -> Nó xen các commit của nhánh A vào trước các commit của nhánh hiện tại.
pb: git rebase --abort sẽ abort cái rebase và checkout về original branch; git rebase --quit sẽ abort và giữ HEAD ở đúng vị trí hiện tại

git rebase -i HEAD~N -> p là commit giữ lại, s là squash sử dụng commit này nhưng đè vào commit trước đó, r là giữ lại commit này nhưng viết lại message

Cách xóa 1 commit trên local: git rebase -i HEAD~N -> i -> commit mới nhất ở dưới cùng, muốn xóa commit nào thì xóa dòng của commit đó. Nếu k có conflict thì commit tự được xóa thành công. Nếu có conflict -> chọn -> git add . -> git rebase --continue -> s -> đổi message nếu thích -> :wq
Hàm rebase set lại tập file ở base và xử lý cái file hiện tại so với base. Tức git rebase -i HEAD~2 sẽ cho base bỏ ra 2 commit cuối và ta thao tác gì kệ ta theo các option-> sau đó sẽ nối lại và trong quá trình nối mà khác với thành phần base cuối thì phải resolve.
Để xóa commit ở remote: đồng bộ remote và local -> xóa commit đó ở local -> git push origin +master => dấu + trước tên nhánh sẽ ép hàm push thực hiện. Ta cx có thể xóa trên remote bằng lệnh git reset --soft/--hard HEAD~N r sau đó gọi git push origin +<nhánh cx đc>



# Git merge
Có thể thêm 1 repos khác vào repos hiện tại, cứ clone trực tiếp về. Nhưng push lên sẽ k thấy, phải dùng submodule.
Thêm 1 repos vào repos nhưng dưới dạng submodule: git submodule add <url> <tên submodule> => submodule giúp cho 1 module có thể dùng nhiều nơi

Cách khác là tạo 1 pull request để merge. Trong các dự án khi mà các thành viên k thực sự thân nhau thì vc tạo pull request rất quan trọng chứ kp kiểu nói mồm ai vào check như bth.

git merge --abort => VD khi merge gặp conflict thì quay lại trạng thái trước khi merge, thay vì làm cho phần code mới về tồn tại ở uncommitted

Sau khi gọi merge: git mergetool => git mergetool --tool-help -> git mergetool --tool=<vimdiff/ tên tool> => dùng tool gì thì ghi vào. Trong VSC có sẵn tool giao diện để merge r



# git pull => bỏ git fetch
Nếu repos bị xóa commit mà local muốn cập nhập: git pull --rebase = git pull --rebase origin -> lệnh duy nhất cho phép biến base của remote thành base local

git pull origin master => Khi pull ở 1 remote đã có r từ 1 local trống. Nếu dùng git branch --set-upstream-to=origin/<branch> master thì các lần sau chỉ cần git pull thôi
Mỗi nhánh có 1 pull stream và 1 push stream riêng, mỗi khi ta có 1 nhánh mới thì ta phải set pull stream và push stream cho nhánh đó
Ở nhánh test1, k thể push lên test2, phải checkout ra test2 r push nếu muốn.



# Các loại file git
-> .gitignore thêm các file build tự sinh ra hoặc thư viện tự cài, hoặc giúp giữ kín các file qtr nếu repo đang là public.
.gitignore ảnh hưởng mọi file và thư mục nên 1 dự án chỉ cần 1 file là đủ.

Ta đặt file .gitignore vào thư mục root project thì git sẽ check và bỏ qua các file trong đó. Đó mới là điều kiện cần, điều kiện đủ phải là files k có git cache thì git mới bỏ qua, nếu k thì .gitignore cũng vô dụng => thường ta chả đụng gì đến git cache

=> Tool: https://www.toptal.com/developers/gitignore tạo file gitignore phổ biến cho nhiều loại dự án

-> .gitkeep: cho vào 1 folder trống thì folder đó vẫn được push lên git => chống được cả .gitignore

-> .gitattributes: cấu hình các thuộc tính trong git. Có tool sinh ra file .gitattributes cho các loại dự án khác nhau. Với nó ta có thể bảo khi các file được commit hay làm gì thì loại file nào sẽ thao tác được thêm tính năng nào đó như so sánh sự khác biệt hay lọc => ít dùng



# git tag 
1 tag chỉ gắn được vào 1 commit => ít dùng
git tag = git tag -l = git tag --list => liệt kê các tag
git tag -n => liệt kê các tag kèm message
git tag -a <tên tag> -m "Phien ban thu nghiem" => tạo ra 1 tag và gắn vào commit cuối
git tag -a <tên tag> -m "Phien ban thu nghiem 2" 9fceb02 => tạo 1 tag mới và đánh dấu vào commit cũ nào
git show <tên tag> => xem thông tin về commit được gắn tag nào
git tag <tên tag cũ> -f -m "<nd mới>" => update tag cũ thành nội dung mới là gì
git tag <tên tag mới> <tên tag cũ> -f -m "<nd mới>" => tạo ra 1 tag mới cùng vị trí với tag cũ có nd là gì
git push origin <tên tag> -> hàm git push chỉ cập nhập các dữ liệu k có tag
git push origin --tags -> cập nhập tất cả các tag
git checkout <tên tag> => trỏ HEAD đến commit được gắn tag nào -> thay thế cho vc dùng mã hash khó nhớ
git checkout -b <tên branch> <tên tag> => tạo luôn nhánh mới co tên là gì từ commit có gắn với tag name nào => dùng tên tag thay cho mã hash trong các lệnh được
git push --delete origin <tên tag> => xóa tag nào ở remote
git tag -d <tên tag> => xóa tag nào ở local 



# Mô hình git
Có nhiều loại như trunk-based development

Vc dùng git flow có thể xử lý các dự án lớn nhưng các dự án cực kỳ lớn thì lại là vấn đề khác. Vc chia branch làm 1 tính năng nhưng nếu tính năng lớn làm cả tháng mới xong và có rất nhiều nhánh branch như v cần được merge cùng lúc thì lúc viết và test đơn k có lỗi nhưng merge vào và QA test lại ra 1 đống bug. Nếu tính năng ấy cuối cùng khách hàng lại bảo chưa cần và tạm thời ẩn đi thì càng đau não, xong các vấn đề kiểu merge nhầm nhánh cũng khó xử lý. 
=> Mô hình trunk-based dev sẽ chỉ có 1 nhánh duy nhất mà tất cả mọi người cùng merge chung vào. 
Các tính năng đang làm dở có thể merge chung vào code production vì đằng nào tính năng đó cũng sẽ được tích hợp vào về sau. Ta merge luôn khi có vài chục thay đổi(toàn vẹn và chạy được) còn hơn là merge khi mỗi branch con có đến hàng trăm thay đổi và rơi vào cái bẫy trên. VD 1 tính năng có 100 module thì xong mỗi module là merge vào 1 nhánh chung luôn, điều này sẽ xử lý các vấn đề k tương thích, conflict được phát hiện từ sơm thay vì làm tất cả r merge mới phát hiện ra. Các module chẳng may có quan hệ với nhau thì có thể trao đổi để tái sử dụng của nhau luôn để giảm thiểu code trùng. 
Mỗi tính năng có thể code thêm flag để bật, có vấn đề thì tắt flag đi là xong. Code có sẵn nên chỉnh sửa ít nhất có thể và đảm bảo tương thích với version cũ
Nhánh release sẽ lấy từ nhánh chính ra và k có ai được thao tác trên nhánh release. Nếu có bug thì fix trên nhánh chính r lại cherry pick sang nhánh release. 
=> Tại sao lại cần đội ngũ chuyên nghiệp khi dùng mô hình này? Mọi người phải có ý thức vì nếu 1 ai đó xóa tính năng của người khác hay đụng đến code người khác có thể gây rối loạn. Vc commit code phải được thực hiện trên từng cục nhỏ, k còn là tính năng mà chỉ là 1 phần tính năng. Vì code của tất cả nằm chung 1 chỗ nên 1 người bị lỗi thì mọi người đều lỗi nên code phải được review cẩn thận trước khi merge vào nhánh chính. Mọi người phải commit thường xuyên và hiển nhiên commit thì cũng phải pull thường xuyên. 

-> Git branching strategies mỗi flow có ưu nhược riêng: git flow, github flow, gitlab flow
https://www.gitkraken.com/learn/git/git-flow 
=> Nên dùng github flow, cũng chỉ là cách đặt tên nhánh feat/..., tạo pull request, nhánh develop phát triển liên tục, nhánh feat mở rộng từ nhánh develop, nhánh hotfix fix cái trong main, nhánh main phải là sản phẩm có khả năng deploy lấy từ nhánh develop ra trong quá trình làm. 
Còn versioning có thể tạo từng branch là đóng gói 1 version. 



# Gitflow workflow
Gitflow Workflow định nghĩa cấu trúc phân nhánh nghiêm ngặt phù hợp với mô hình scrum. 5 loại branch cơ bản mà mọi dự án phải có:
- master: có nhiều mốc và mỗi mốc là 1 bản ứng với 1 version. Được gắn tag trên mỗi version để người dùng vào biết là version bao nhiêu mà dùng. Nhánh này chỉ có commit khởi tạo và commit merge vào từ nhánh khác.
- hotfix: nhánh này check out từ base là master và fix các lỗi chỉ có trên môi trường production r lại merge vào master, đúng quy tắc k ai thay đổi trực tiếp mã nguồn trên master nên phải làm như này. Nhánh này cần được check kỹ và test cẩn thận r mới merge vào master, sau khi merge có thể bỏ đi
- develop: được lấy từ master branch để bắt đầu code cho dự án từ đầu tới cuối. Khi hoàn thành xong sẽ merge nó vào branch release để tạo ra 1 bản sao release cho sản phẩm. Trước khi merge vào branch release, nó cần được test xong chạy hoàn toàn ổn trên môi trường kiểm thử
- release: code lấy từ branch develop khi xong hoàn toàn 1 bản version của sản phẩm. Tại đây code cần được test trên môi trường thực tế trong phạm vi có thể(vì kp lúc nào cx test trên thực tế được luôn). Test kỹ càng và có được 1 bản build release để merge lên branch master và gắn tag vào là 1 version mới
- feature: có thể có nhiều nhánh feature, các nhánh này đều checkout từ develop và phát triển 1 feature mới theo chuẩn đặt tên feature/<tên feature>. Code xong sẽ request đến branch develop để teamlead merge vào develop.
=> Trong này chỉ có nhánh master, develop, release là luôn duy trì đến cuối dự án, nhánh feature hay hotfix sau khi merge thì có thể bỏ đi.
Có nhiều cách chia branch kiểu khác vì có nơi họ dùng mỗi nhánh là 1 version. Còn nhiều loại nhánh khác mà tạo ra theo yêu cầu của dự án như pre-pro, QC, BugFix,..

VD: có 1 dự án mới, ta tạo ra nhánh master chứa mỗi gitignore -> checkout từ master ra develop -> setup dự án chưa có gì là version 0 -> merge lên master -> checkout từ develop ra 1 feature -> code xong feature thì tạo pullrequest merge lên develop -> develop test xong có lỗi thì lại checkout feature fix or chỉnh sửa trực tiếp -> k có lỗi thì merge lên release -> test trên môi trường thực tế trong phạm vi có thể, nếu có lỗi thì chỉnh trực tiếp or develop fix r lại merge tiếp vào release -> merge lên master và gắn tag version 1 -> master bị lỗi thì checkout ra hotfix -> fix xong lại test r merge lên master đánh version v1.1 -> nhánh develop lại lấy tiếp từ nhánh master(chú ý nhánh develop có thể đổi từ trước nên lúc này data phải có bugfix hết từ master và phần code mới của develop vẫn ok) -> code tiếp tính năng cho v2 của ứng dụng và quy trình lặp lại



# Other
-> Tình huống: Join vào project, pull code về và bị conflict liên tục vì mấy file rác sinh ra. Khi đó ta nhét các file đó vào trong .gitignore r xóa file rác đi và commit lên -> 1 ông khác lại pull về và tạo lại file rác đó và ông ta cũng push lên -> file rác đó vẫn dính vào git bth dù đã nhét vào .gitignore 
=> NN là vì file đó được git cache thu nạp r nên gitignore k có tác dụng, phải xóa bỏ nó bằng dòng lệnh: git rm -r --cached /<link to file or folder đó> thì nó k còn bị dinh gitcache nx và k hiện nx. 
=> Thông thường khi thêm gitignore, ta nên xóa bỏ hết file của gitcache luôn để gitignore hoạt động đúng (xóa bỏ hết file của git cache thoải mái chả ảnh hưởng gì đâu) với: git rm -r --cached

-> Tình huống: đang ở nhánh master, ta checkout sang 1 nhánh mới, thao tác trên nhánh mới, nhưng r muốn nhánh master có những thứ đó => commit lên r quay về master và merge nó với nhanh đó. Tương tự nhưng đang ở nhánh detach tạm thời => ta k thể có cách nào mà k tạo nhánh mới được vì k merge được, buộc tạo nhánh mới từ nhánh tạm thời r làm tương tự. Nếu k cho checkout thì ta cứ checkout -f rồi gọi merge thôi

-> Tổng kết cơ bản:
=> Khởi tạo repos local và liên kết với remote và trỏ tới branch master
git init
git remote add origin <link to empty repos>
git push --set-upstream origin master => commit r mới gọi
=> Commit mọi thay đổi:
git add .
git commit -m "<message>"
git push
=> Tạo pull request:
git checkout -b <child>
<đổi>
git add .
git commit -m "<message>"
git push

-> Tổng kết các thứ:
Ta có thể dùng 1 dự án có sẵn trong dự án đang làm dở của ta: ở trong dự án đang làm dở -> git submodule add <url> <submodule>
Ta có thể dùng 1 commit cũ của dự án hiện tại thành hiện tại của dự án hiện tại: ở dự án hiện tại -> git checkout <mã hash commit> . -> commit -> push
Ta có thể thêm .gitignore cho dự án: thêm file .gitignore -> ghi các file muốn ignore -> git rm -r --cached -> git add -> commit -> push
Ta có thể dùng 1 commit cũ của 1 dự án khác vào 1 dự án đang dở hiện tại: clone dự án đang làm dở -> git submodule add <url> <tên submodule> -> cd thư mục submodule -> git checkout <mã hash của lần commit cũ> -> cd .. -> git add -> git commit -> push => tương tự dùng cho 1 dự án mới cũng thế thôi
Ta có thể gom các commit ở local lại làm ở local và commit lên github 1 commit duy nhất: Tạo ra vài commit, giả sử gom 3 commit trên cùng thành 1 -> git rebase -i HEAD~<number commits> -> sửa các commit muốn merge từ pick thành s để merge nó lên commit phía trước k có s mà nó gặp đầu tiên -> ESC-> :wq + Enter (-> nếu k cho chỉnh sửa comment luôn thì: git rebase --continue or muốn kết thúc thì git rebase --quit) -> ấn I để sửa -> comment các commit k cần với # và chỉnh sửa comment of commit -> ESC -> :wq + Enter

Setup môi trường là vc rất quan trọng của sysadmin, CTO, Tech leader, DevOps:
Local: máy của dev, chỉ 1 người access
Staging/QA environment: môi trường của team dev, môi trường để test khi code của ta tích hợp với code người khác thì có chạy đúng k, test thành công là cho lên production. Dev, Product Manager, BA, Tester được access.
Production env: là người dùng thật, dữ liệu thật. Chỉ DBA, DevOps, Sysadmin, dev thân tín mới có thể truy cập vì sản phẩm đang chạy đụng hỏng là thiệt hại rất lớn. Nếu k phân quyền rõ ràng thì chẳng may xóa nhầm data production là toang.
=> Staging và Production nên đồng bộ về phần cứng tức môi trường dùng server giống nhau, data cx nên đồng bộ, nếu là data nhạy cảm cần mask lại trước khi sync.

-> Thao tác với gitbash:
Copy trong Git Bash: giữ SHIFT -> left or right key-> enter
Paste trong GitBash: Insert
less <link tới file> => đọc file từng page, Q để dừng

-> URL: https://star-history.com/#oven-sh/bun&Date
Trang thống kê sự thay đổi star, nó cho biết 1 dự án được cộng đồng ủng hộ với tốc độ tăng trưởng như thế nào

-> Gitbook: Tool mạnh nhất tạo products docs. Nó k giúp tạo blog website mà dùng để tạo document kiểu hướng dẫn sử dụng product. 
Tutorial dùng luôn trên VSC: https://code-literacy.medium.com/publish-your-book-online-with-gitbook-fc0ce9b7f12
URL: https://manage.wix.com/dashboard => Web tạo blog thuần túy



